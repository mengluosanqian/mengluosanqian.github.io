<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/" class="post-title-link" itemprop="url">浏览器安全</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-06 16:19:50" itemprop="dateCreated datePublished" datetime="2022-03-06T16:19:50+08:00">2022-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-09 21:50:40" itemprop="dateModified" datetime="2022-03-09T21:50:40+08:00">2022-03-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h2><h3 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h3><h4 id="什么是XSS攻击"><a href="#什么是XSS攻击" class="headerlink" title="什么是XSS攻击"></a>什么是XSS攻击</h4><ol>
<li>xss攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户信息。</li>
<li>xss的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没办法分辨哪些脚本是可信的，从而导致了恶意代码的执行</li>
<li>攻击者可以通过这种攻击方式进行以下操作<ul>
<li>获取页面数据，如DOM,COOKIE,localStorage</li>
<li>DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器</li>
<li>破坏页面结构</li>
<li>流量劫持（将链接指向某网站）</li>
</ul>
</li>
</ol>
<h4 id="XSS攻击类型"><a href="#XSS攻击类型" class="headerlink" title="XSS攻击类型"></a>XSS攻击类型</h4><ol>
<li>存储型<ul>
<li>恶意脚本会存储在目标服务器上，当浏览器请求资源时，脚本从服务器传回并执行</li>
</ul>
</li>
<li>反射型<ul>
<li>攻击者诱导用户访问一个带有恶意代码的URL后，服务端接收数据后处理，然后把带有恶意代码的数据发送的浏览器端，浏览器端解析这段带有XSS代码的数据后当做脚本执行，最终完成xss攻击</li>
</ul>
</li>
<li>DOM型<ul>
<li>通过修改页面的DOM节点形成的XSS</li>
</ul>
</li>
</ol>
<h4 id="存储型-XSS-的攻击步骤："><a href="#存储型-XSS-的攻击步骤：" class="headerlink" title="存储型 XSS 的攻击步骤："></a>存储型 XSS 的攻击步骤：</h4><ol>
<li>攻击者将恶意代码提交到⽬标⽹站的数据库中。</li>
<li>⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li>
<li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</li>
<li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。<br>这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评论、⽤户私信等</li>
</ol>
<h4 id="反射型-XSS-的攻击步骤："><a href="#反射型-XSS-的攻击步骤：" class="headerlink" title="反射型 XSS 的攻击步骤："></a>反射型 XSS 的攻击步骤：</h4><ol>
<li>攻击者构造出特殊的 URL，其中包含恶意代码。</li>
<li>⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li>
<li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。</li>
<li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li>
</ol>
<p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。<br>反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。</p>
<h4 id="DOM-型-XSS-的攻击步骤："><a href="#DOM-型-XSS-的攻击步骤：" class="headerlink" title="DOM 型 XSS 的攻击步骤："></a>DOM 型 XSS 的攻击步骤：</h4><ol>
<li>攻击者构造出特殊的 URL，其中包含恶意代码。</li>
<li>⽤户打开带有恶意代码的 URL。</li>
<li>⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL 中的恶意代码并执⾏。</li>
<li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li>
</ol>
<p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。</p>
<h4 id="如何防御xss攻击"><a href="#如何防御xss攻击" class="headerlink" title="如何防御xss攻击"></a>如何防御xss攻击</h4><ol>
<li>可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。</li>
<li>使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。<ul>
<li>CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。</li>
<li>通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式</li>
</ul>
</li>
<li>对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。</li>
</ol>
<h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><h4 id="什么是CSRF攻击"><a href="#什么是CSRF攻击" class="headerlink" title="什么是CSRF攻击"></a>什么是CSRF攻击</h4><ol>
<li>CSRF攻击指的是跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户想服务端执行一些操作</li>
<li>CSRF攻击的本质是利用cookie会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充</li>
</ol>
<h4 id="攻击类型"><a href="#攻击类型" class="headerlink" title="攻击类型"></a>攻击类型</h4><ol>
<li>GET类型的CSRF攻击<ul>
<li>比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。</li>
</ul>
</li>
<li>POST 类型的 CSRF 攻击<ul>
<li>比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。</li>
</ul>
</li>
<li>链接类型的 CSRF 攻击<ul>
<li>比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。</li>
</ul>
</li>
</ol>
<h4 id="如何防御CSRF攻击"><a href="#如何防御CSRF攻击" class="headerlink" title="如何防御CSRF攻击"></a>如何防御CSRF攻击</h4><ol>
<li>进行同源检测<ul>
<li>服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer 字段会告诉服务器该网页是从哪个页面链接过来的）</li>
</ul>
</li>
<li>使用 CSRF Token 进行验证<ul>
<li>服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。</li>
</ul>
</li>
<li>对 Cookie 进行双重验证<ul>
<li>服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。</li>
</ul>
</li>
<li>在设置 cookie 属性的时候设置 Samesite<ul>
<li>限制 cookie 不能作为被第三方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用</li>
</ul>
</li>
</ol>
<h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><h4 id="什么是中间人攻击"><a href="#什么是中间人攻击" class="headerlink" title="什么是中间人攻击"></a>什么是中间人攻击</h4><p>中间⼈ (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话, 但事实上整个会话都被攻击者完全控制。在中间⼈攻击中，攻击者可以拦截通讯双⽅的通话并插⼊新的内容。</p>
<h4 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h4><ol>
<li>客户端发送请求到服务端，请求被中间⼈截获</li>
<li>服务器向客户端发送公钥</li>
<li>中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个伪造的公钥，发给客户端</li>
<li>客户端收到伪造的公钥后，⽣成加密hash值发给服务器</li>
<li>中间⼈获得加密hash值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密hash值，发给服务器</li>
<li>服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端</li>
</ol>
<h3 id="有哪些可能引起前端安全的问题"><a href="#有哪些可能引起前端安全的问题" class="headerlink" title="有哪些可能引起前端安全的问题"></a>有哪些可能引起前端安全的问题</h3><ol>
<li>跨站脚本攻击（xss）</li>
<li>iframe的滥用</li>
<li>跨站点请求伪造（csrf）</li>
<li>恶意的第三方库</li>
</ol>
<h3 id="网站劫持"><a href="#网站劫持" class="headerlink" title="网站劫持"></a>网站劫持</h3><ol>
<li><p>DNS劫持</p>
<ul>
<li>输⼊京东被强制跳转到淘宝这就属于dns劫持</li>
<li>DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器</li>
<li>302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容</li>
</ul>
</li>
<li><p>HTTP劫持: </p>
<ul>
<li>访问⾕歌但是⼀直有⼴告</li>
<li>由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告)</li>
</ul>
</li>
<li><p>DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。</p>
</li>
</ol>
<h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h3><ol>
<li>就是通过把sql命令插入到web表单提交或输入域名、页面请求的查询字符串，最终达到欺骗服务器执行恶意SQL命令</li>
<li>防护：<ul>
<li>永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双“-”进行转换等</li>
<li>永远不要动态拼装SQL,可以使用参数化的SQL或直接使用存储过程进行数据查询存储</li>
<li>永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接</li>
<li>不要把机密信息明文存放，请加密或者hash掉密码和敏感信息</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9C%B0%E5%9D%80%E6%A0%8F%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E5%B1%95%E7%A4%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9C%B0%E5%9D%80%E6%A0%8F%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E5%B1%95%E7%A4%BA/" class="post-title-link" itemprop="url">地址栏从输入URL到展示</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-03-06 00:07:33 / Modified: 16:00:51" itemprop="dateCreated datePublished" datetime="2022-03-06T00:07:33+08:00">2022-03-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><ol>
<li>用户在地址栏输入URL后，浏览器会先检查是否有缓存，如果是https的话，先找service Worker，如果没有，在找浏览器的内存缓存，如果还没有找到，再找硬盘缓存（通常所说的<code>强缓存</code>和<code>协商缓存</code>都属于硬盘缓存），如果还没有找到的话，再查找推送缓存</li>
<li>如果缓存中没有找到或者缓存过期，则开始解析URL。把URL中所需要的协议、域名、端口、路径等信息提取出来，根据解析出的域名，进行DNS解析，查找出请求服务器的IP地址</li>
<li>拿到IP地址后，根据拿到的IP地址，发起TCP请求，经过<code>三次握手</code>后建立TCP连接</li>
<li>TCP连接建立之后，浏览器可以和服务器进行通信，即开始发送HTTP请求，需要携带请求行、请求头、请求体<ul>
<li>请求行：请求方法 + 请求URI + HTTP版本协议</li>
<li>请求头：里面包括了缓存相关信息，以及下面的信息</li>
<li>请求体：请求体只有在POST方法下存在，常见的场景是表单提交<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Accept</span>: text/html,application/xhtml+xml,application/xml;q=<span class="number">0.9</span>,image/webp,image/apng,*<span class="comment">/*;q=0.8,application/signed-exchange;v=b3</span></span><br><span class="line"><span class="comment">Accept-Encoding: gzip, deflate, br</span></span><br><span class="line"><span class="comment">Accept-Language: zh-CN,zh;q=0.9</span></span><br><span class="line"><span class="comment">Cache-Control: no-cache</span></span><br><span class="line"><span class="comment">Connection: keep-alive</span></span><br><span class="line"><span class="comment">Cookie: /* 省略cookie信息 */</span></span><br><span class="line"><span class="title class_">Host</span>: www.<span class="property">baidu</span>.<span class="property">com</span></span><br><span class="line"><span class="title class_">Pragma</span>: no-cache</span><br><span class="line"><span class="title class_">Upgrade</span>-<span class="title class_">Insecure</span>-<span class="title class_">Requests</span>: <span class="number">1</span></span><br><span class="line"><span class="title class_">User</span>-<span class="title class_">Agent</span>: <span class="title class_">Mozilla</span>/<span class="number">5.0</span> (iPhone; <span class="variable constant_">CPU</span> iPhone <span class="variable constant_">OS</span> <span class="number">11_0</span> like <span class="title class_">Mac</span> <span class="variable constant_">OS</span> X) <span class="title class_">AppleWebKit</span>/<span class="number">604.1</span><span class="number">.38</span> (<span class="variable constant_">KHTML</span>, like <span class="title class_">Gecko</span>) <span class="title class_">Version</span>/<span class="number">11.0</span> <span class="title class_">Mobile</span>/15A372 <span class="title class_">Safari</span>/<span class="number">604.1</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>根据请求头中的信息，如果存在expries或者cache-control，则先进行强缓存的判断，如果强缓存过期，则携带协商缓存的标志（last-modified）发起请求，如果协商缓存没有过期，则返回304和资源信息，如果缓存已经过期，则向服务器发起请求，查找到资源后就返回200和资源信息。</li>
<li>请求完成后，根据响应头中的connection:keep-alive判断是否建立持久连接，如果保持持久连接，之后请求统一站点的资源会复用这个连接，如果没有这个字段，则断开连接，tcp断开连接经过四次挥手。</li>
<li>拿到请求数据后，开始解析数据，构建DOM树和CSSOM树，将这两个数渲染成render树</li>
<li>根据生成的render树建立图层树，生成绘制列表，生成图块并栅格化，最后将内容在显示器上显示出来</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%92%8CUDP/" class="post-title-link" itemprop="url">TCP和UDP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-03 21:23:34" itemprop="dateCreated datePublished" datetime="2022-03-03T21:23:34+08:00">2022-03-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-05 20:38:41" itemprop="dateModified" datetime="2022-03-05T20:38:41+08:00">2022-03-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="TCP-UDP"><a href="#TCP-UDP" class="headerlink" title="TCP&#x2F;UDP"></a>TCP&#x2F;UDP</h3><p>TCP&#x2F;IP中两个具有代表性的传输层协议，分别是TCP和UDP</p>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><ol>
<li>UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。</li>
<li>UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全到达的</li>
<li>UDP的特点：<ul>
<li>面向无连接<ul>
<li>不需要和TCP一样在发送数据前进行三次握手建立连接</li>
<li>不会对数据报文进行任何拆分和拼接操作</li>
<li>在发送端，应用层将数据传递给传输层的UDP协议，UDP只会给数据增加一个UDP头标识下是UDP协议，然后就传递给了网络层</li>
<li>在接收端，网络层将数据传递给传输层，UDP只去除IP报文头就传递给应用层，不会进行任何拼接操作</li>
</ul>
</li>
<li>有单播、多播、广播的功能<ul>
<li>UDP不止支持一对一的传输方式，同时支持一对多，多对多，多对一的方式</li>
</ul>
</li>
<li>udp是面向报文的<ul>
<li>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。</li>
</ul>
</li>
<li>不可靠性<ul>
<li>UDP是无连接的，通信不需要建立连接，因此是不可靠的</li>
<li>不会备份数据，也不关心是否成功接收到传输的数据</li>
<li>没有拥堵控制，一直会以恒定的速度发送数据，网络环境不好时会发生丢包</li>
</ul>
</li>
<li>头部开销小，传输数据报文时是很高效的<ul>
<li>头部只有八字节，比TCP的至少20字节要少的多</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><ol>
<li>TCP协议全称是传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议</li>
<li>TCP是面向协议的、可靠的流协议</li>
<li>TCP连接过程就是通常所说的三次握手过程</li>
</ol>
<ul>
<li>第一次握手，建立连接时，客户端发送syn（<code>同步序列编号</code>，syn&#x3D;j）包到服务器，并进入SYN_SENT状态，等待服务器确认</li>
<li>第二次握手，服务器收到syn包并确认客户的SYN（ack&#x3D;j+1），同时也发送一个自己的SYN包（syn&#x3D;k），即syn+ack包，此时服务器进入SYN_RECV状态</li>
<li>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack&#x3D;k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li>
</ul>
<ol start="4">
<li>TCP断开连接的过程就是通常所说的四次挥手过程</li>
<li>TCP协议的特点：<ul>
<li>面向连接<ul>
<li>是指发送数据之前必须在两端简历链接，简历链接的方法是“三次握手”，这样能建立可靠的链接。</li>
</ul>
</li>
<li>仅支持单播传输<ul>
<li>每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</li>
</ul>
</li>
<li>面向字节流<ul>
<li>TCP不像UDP一样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输</li>
</ul>
</li>
<li>可靠传输</li>
<li>提供拥塞控制<ul>
<li>当网络出现拥堵的时候，TCP能给减少向网络注入数据的速率和数量，缓解拥塞</li>
</ul>
</li>
<li>TCP提供全双工通信<ul>
<li>TCP允许通信双方的应用程序在任何时候都能发送数据，因为 TCP连接的两端都设有缓存，用来临时存放双向通信的数据</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><ol>
<li>TCP向上层提供面向连接的可靠服务，UDP向上层提供无连接的不可靠服务</li>
<li>虽然UDP并没有TCP传输来的准确，但是也能在很多实时性要求高的地方有所作为</li>
<li>对数据准确性要求较高的，速度可以相对较慢的，可以选用TCP</li>
</ol>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">UDP</th>
<th align="center">TCP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">是否连接</td>
<td align="center">无连接</td>
<td align="center">面向连接</td>
</tr>
<tr>
<td align="center">是否可靠</td>
<td align="center">不可靠传输，不使用流量控制和拥塞控制</td>
<td align="center">可靠传输，使用流量控制和拥塞控制</td>
</tr>
<tr>
<td align="center">连接对象个数</td>
<td align="center">支持一对一、一对多、多对一、多对多交互通信</td>
<td align="center">只能是一对一通信</td>
</tr>
<tr>
<td align="center">传输方式</td>
<td align="center">面向报文</td>
<td align="center">面向字节流</td>
</tr>
<tr>
<td align="center">首部开销</td>
<td align="center">首部开销小，仅8字节</td>
<td align="center">首部最小20字节，最大60字节</td>
</tr>
<tr>
<td align="center">适用场景</td>
<td align="center">适用于实时应用（IP电话、视频会议、直播等）</td>
<td align="center">适用于要求可靠传输的应用，例如文件传输</td>
</tr>
</tbody></table>
<h3 id="TCP-IP如何保证数据包传输的有序可靠"><a href="#TCP-IP如何保证数据包传输的有序可靠" class="headerlink" title="TCP&#x2F;IP如何保证数据包传输的有序可靠"></a>TCP&#x2F;IP如何保证数据包传输的有序可靠</h3><p>对于字节流分段并进行编号然后通过<code>ACK回复</code>和<code>超时重发</code>两个机制来保证</p>
<ol>
<li>为了保证数据包的可靠传输，发送方必须把已发送的数据包保留在缓存区</li>
<li>并为每个已发送的数据包启动一个超时定时器</li>
<li>如在定时器超时之前收到了对方发来的应答信息（可能是对本包的应答，也可以是对本包后续包的应答），则释放该数据包占据的缓存区</li>
<li>否则，重传该数据包，直到接收到应答或者重传次数超过规定的最大次数为止</li>
<li>接收方收到数据包后，先进性CRC（循环冗余校验）校验，如果正确把数据交给上层协议，然后给发送方发送一个累计应答包，表示该数据已收到，如果接收方正好也有数据要发给发送方，应答包也可在数据包中携带过去。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OSI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/OSI/" class="post-title-link" itemprop="url">OSI</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-03-03 00:08:22 / Modified: 00:08:56" itemprop="dateCreated datePublished" datetime="2022-03-03T00:08:22+08:00">2022-03-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h3><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><ol>
<li>OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。</li>
<li>常见的应用层的网络协议有：HTTP,HTTPS,FTP,POP3,SMTP等</li>
</ol>
<h4 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h4><ol>
<li>表示层提供各种用于应用层数据的编码和转换功能，确保一个系统的应用层发送的数据能被另一个系统的应用层识别。</li>
<li>如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。</li>
<li>数据压缩和加密也是表示层可提供的转化功能</li>
</ol>
<h4 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h4><ol>
<li>负责建立、管理和终止表示层实体之间的通信会话。</li>
<li>该层的通信由不同设备中的应用程序之间的服务请求和响应组成</li>
</ol>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><ol>
<li>传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。</li>
<li>该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。</li>
<li>TCP UDP就是在这一层，端口号即是这里的端</li>
</ol>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><ol>
<li>本层通过IP寻址来建立两个节点间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误的按照地址传送给目的端的运输层，就是通常所说的IP层。</li>
<li>这一层就是我们经常说的IP协议层</li>
</ol>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><ol>
<li>将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。</li>
<li>数据链路层又分为2个子层：逻辑链路控制子层（LLC）和媒体访问控制子层（MAC）。</li>
<li>MAC子层处理CSMA&#x2F;CD算法、数据出错校验、成帧等；LLC子层定义了一些字段使上次协议能共享数据链路层。 在实际使用中，LLC子层并非必需的。</li>
</ol>
<h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</p>
<h3 id="TCP-IP五层模型"><a href="#TCP-IP五层模型" class="headerlink" title="TCP&#x2F;IP五层模型"></a>TCP&#x2F;IP五层模型</h3><h4 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h4><h4 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h4><h4 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h4><h4 id="数据链路层-1"><a href="#数据链路层-1" class="headerlink" title="数据链路层"></a>数据链路层</h4><h4 id="物理层-1"><a href="#物理层-1" class="headerlink" title="物理层"></a>物理层</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E8%A1%A5%E5%85%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E8%A1%A5%E5%85%85/" class="post-title-link" itemprop="url">HTTP补充</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-02 23:20:32" itemprop="dateCreated datePublished" datetime="2022-03-02T23:20:32+08:00">2022-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-21 11:09:11" itemprop="dateModified" datetime="2022-06-21T11:09:11+08:00">2022-06-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="HTTP补充"><a href="#HTTP补充" class="headerlink" title="HTTP补充"></a>HTTP补充</h2><h3 id="Accept字段"><a href="#Accept字段" class="headerlink" title="Accept字段"></a>Accept字段</h3><p>Accept字段主要由四部分组成：<code>数据格式、压缩方式、支持语言和字符集</code></p>
<h4 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h4><p>对于发送方来说，报文 body 部分的数据类型，这些类型体现在Content-Type这个字段。接收端想要收到特定类型的数据，也可以用Accept字段。<br>这两个字段可以分为下面几类：</p>
<ol>
<li>text： text&#x2F;html, text&#x2F;plain, text&#x2F;css 等</li>
<li>image: image&#x2F;gif, image&#x2F;jpeg, image&#x2F;png 等</li>
<li>audio&#x2F;video: audio&#x2F;mpeg, video&#x2F;mp4 等</li>
<li>application: application&#x2F;json, application&#x2F;javascript, application&#x2F;pdf, application&#x2F;octet-stream</li>
</ol>
<h4 id="压缩方式"><a href="#压缩方式" class="headerlink" title="压缩方式"></a>压缩方式</h4><p>当然一般这些数据都是会进行编码压缩的，采取什么样的压缩方式就体现在了发送方的Content-Encoding字段上， 同样的，接收什么样的压缩方式体现在了接受方的Accept-Encoding字段上。这个字段的取值有下面几种：</p>
<ol>
<li>gzip: 当今最流行的压缩格式</li>
<li>deflate: 另外一种著名的压缩格式</li>
<li>br: 一种专门为 HTTP 发明的压缩算法</li>
</ol>
<h4 id="支持语言"><a href="#支持语言" class="headerlink" title="支持语言"></a>支持语言</h4><p>对于发送方而言，还有一个Content-Language字段，在需要实现国际化的方案当中，可以用来指定支持的语言，在接受方对应的字段为Accept-Language</p>
<h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><p>最后是一个比较特殊的字段, 在接收端对应为Accept-Charset，指定可以接受的字符集，而在发送端并没有对应的Content-Charset, 而是直接放在了Content-Type中，以charset属性指定<br>HTTP请求处理表单数据的提交，体现在两种不同的Content-Type取值:application&#x2F;x-www-form-urlencoded<br>multipart&#x2F;form-data</p>
<h3 id="HTTP版本"><a href="#HTTP版本" class="headerlink" title="HTTP版本"></a>HTTP版本</h3><p>HTTP传输是基于请求-应答的模式进行的，报文必须是一发一收，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。</p>
<h4 id="1-0版本"><a href="#1-0版本" class="headerlink" title="1.0版本"></a>1.0版本</h4><ol>
<li>最早的http只是使用在一些较为简单的网页上和网络请求上，所以比较简单，每次请求都打开一个新的TCP连接，收到响应后立即断开连接</li>
<li>后面提供了一个非标准字段connection字段来实现长连接，但是由于非标准字段，所以不同实现的行为可能不一致</li>
<li>支持发送的http请求方式有get、post、head</li>
</ol>
<h4 id="1-1版本"><a href="#1-1版本" class="headerlink" title="1.1版本"></a>1.1版本</h4><ol>
<li>引入了更多的缓存控制策略，如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等</li>
<li>允许范围请求，即在请求头中加入range头部</li>
<li>请求消息和响应消息都必须包含Host头部，以区分同一个物理主机中的不同虚拟主机的域名</li>
<li>默认开启持久连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟</li>
<li>支持持久化连接Persistent Connection，并且默认使用persistent，Connection，在同一个tcp的连接中可以传送多个HTTP请求和响应。多个请求和响应可以重叠。多个请求和响应可以同时进行</li>
<li>Connection请求头的值为keep-alive时，客户端通知服务器返回本次请求结果后保持连接</li>
<li>HTTP1.1还提供了与身份认证、状态管理和Cache缓存等机制相关的请求头和响应头</li>
<li>HTTP1.1支持请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，这种机制容易造成队头堵塞</li>
<li>请求方式增加put、patch、options、delete等。</li>
</ol>
<h4 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h4><ol>
<li>由于HTTPS在安全方面已经做得非常好了，HTTP改进的关注点放在了性能方面，对于HTTP&#x2F;2而言，他对于性能的提升主要在于两点：头部压缩、多路复用</li>
<li>增加双工模式，即不仅客户端能够同时发送多个请求，服务端也能同时处理多个请求，解决了队头堵塞的问题</li>
<li>支持二进制帧的格式来传递报头和数据</li>
<li>头信息压缩机制，头信息使用gzip或compress压缩后再发送</li>
</ol>
<ul>
<li>采用HPACK算法，在客户端和服务器两端建立字典，用索引号表示重复字符串，采用哈夫曼编码啦压缩整数和字符串，可以达到50%~90%的高压缩率</li>
<li>在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送</li>
<li>首部表在HTTP&#x2F;2连接续存期内始终存在，由客户端和服务器共同渐进的更新</li>
<li>每个首部键值对要么被追加到当前表的末尾，要么替换表中之前的值</li>
</ul>
<h4 id="HTTP3-0"><a href="#HTTP3-0" class="headerlink" title="HTTP3.0"></a>HTTP3.0</h4><ol>
<li>由于TCP和UDP两者在运输层存在一定差距，TCP的传递效率与UDP相比有天然劣势，于是google基于UDP开发出了新的协议QUIC（quick UDP internet Connections），希望取代TCP提高传输效率，后经过协商将QUIC更名为HTTP&#x2F;3</li>
<li>UDP比TCP相比效率更高但不具备传输可靠性。而quic便是根据UDP传输效率高这一特点，结合TCP、TLS、http2的优势，加以优化</li>
<li>零RTT建立连接</li>
</ol>
<ul>
<li>仅需一次 RTT(Round-TripTime:往返时延)即可传递数据，如果将其缓存，就可将RTT减少至0</li>
<li>核心是DH秘钥交换算法</li>
</ul>
<ol start="4">
<li>连接迁移</li>
<li>HTTP&#x2F;3基于UDP的传输，不保证连接可靠性，也就没有对头阻塞的后果。同样传输单元与加密单元为Packet，在TLS下也可避免对头阻塞的问题。</li>
<li>拥塞控制：TCP对于拥塞控制在于传输层，quic可在应用层操作改变拥塞控制方法</li>
<li>流量控制：TCP使用滑动窗口的方法对发送方的流量进行控制，而对接收方并无现在，在quic中补齐了这一短板</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/" class="post-title-link" itemprop="url">HTTP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-02 21:29:47" itemprop="dateCreated datePublished" datetime="2022-03-02T21:29:47+08:00">2022-03-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-06-11 17:00:50" itemprop="dateModified" datetime="2022-06-11T17:00:50+08:00">2022-06-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="http和https"><a href="#http和https" class="headerlink" title="http和https"></a>http和https</h3><h4 id="HTTP-1"><a href="#HTTP-1" class="headerlink" title="HTTP"></a>HTTP</h4><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>http：超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从www服务端传输超文本到本地浏览器的传输协议，他可以使浏览器更加高效，使网络传输减少。</p>
<h5 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h5><p>GET: 通常用来获取资源<br>HEAD: 获取资源的元信息<br>POST: 提交数据，即上传数据<br>PUT: 修改数据<br>DELETE: 删除资源(几乎用不到)<br>CONNECT: 建立连接隧道，用于代理服务器<br>OPTIONS: 列出可对资源实行的请求方法，用来跨域请求<br>TRACE: 追踪请求-响应的传输路径</p>
<h5 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h5><ol>
<li>GET请求会被浏览器主动缓存下来，留下历史记录，而POST默认不会</li>
<li>GET只能继续URL编码，只能接收ASCII字符，而POST没有限制</li>
<li>GET是幂等的，而POST不是（幂等表示执行相同的操作，结果也是相同的）</li>
<li>GET请求会把请求报文一次性发出去，而POST会分为两个TCP数据包，首先发header部分，如果服务器响应100，然后发body部分（火狐浏览器除外，他的POST请求只发一个包）</li>
</ol>
<h5 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h5><ol>
<li><p>通用首部</p>
<table>
<thead>
<tr>
<th align="center">通用字段</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">cache-control</td>
<td align="center">控制缓存的行为</td>
</tr>
<tr>
<td align="center">connection</td>
<td align="center">浏览器想要优先使用的连接类型，比如keep-alive</td>
</tr>
<tr>
<td align="center">Date</td>
<td align="center">创建报文时间</td>
</tr>
<tr>
<td align="center">pragma</td>
<td align="center">报文指令</td>
</tr>
<tr>
<td align="center">via</td>
<td align="center">代理服务器相关信息</td>
</tr>
<tr>
<td align="center">transfer-encoding</td>
<td align="center">传输编码方式</td>
</tr>
<tr>
<td align="center">upgrade</td>
<td align="center">要求客户端升级协议</td>
</tr>
<tr>
<td align="center">warning</td>
<td align="center">在内容中可能存在错误</td>
</tr>
</tbody></table>
</li>
<li><p>请求首部</p>
<table>
<thead>
<tr>
<th align="center">请求字段</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">accept</td>
<td align="center">能正确接收的媒体类型</td>
</tr>
<tr>
<td align="center">accept-Charset</td>
<td align="center">能正确接收的字符集</td>
</tr>
<tr>
<td align="center">accept-Encoding</td>
<td align="center">能正确接收的编码格式列表</td>
</tr>
<tr>
<td align="center">accept-language</td>
<td align="center">能正确接收的语言列表</td>
</tr>
<tr>
<td align="center">expect</td>
<td align="center">期待服务器的指定行为</td>
</tr>
<tr>
<td align="center">from</td>
<td align="center">请求方的邮箱地址</td>
</tr>
<tr>
<td align="center">host</td>
<td align="center">服务器的域名</td>
</tr>
<tr>
<td align="center">if-match</td>
<td align="center">两端资源标记对比</td>
</tr>
<tr>
<td align="center">if-modified-since</td>
<td align="center">本地资源未修改返回304（比较时间）</td>
</tr>
<tr>
<td align="center">if-none-match</td>
<td align="center">本地资源未修改返回304（比较标记）</td>
</tr>
<tr>
<td align="center">user-agent</td>
<td align="center">客户端信息</td>
</tr>
<tr>
<td align="center">max-forwards</td>
<td align="center">限制可被代理及网关转发的次数</td>
</tr>
<tr>
<td align="center">proxy-authorization</td>
<td align="center">向代理服务器发送验证信息</td>
</tr>
<tr>
<td align="center">range</td>
<td align="center">请求某个内容的一部分</td>
</tr>
</tbody></table>
</li>
<li><p>响应首部</p>
<table>
<thead>
<tr>
<th align="center">响应字段</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">accept-ranges</td>
<td align="center">是否支持某些种类的范围</td>
</tr>
<tr>
<td align="center">age</td>
<td align="center">资源在代理缓存中存在的时间</td>
</tr>
<tr>
<td align="center">eTag</td>
<td align="center">资源标识</td>
</tr>
<tr>
<td align="center">location</td>
<td align="center">客户端重定向到某个URL</td>
</tr>
<tr>
<td align="center">proxy-authenticate</td>
<td align="center">向代理服务器发送验证信息</td>
</tr>
<tr>
<td align="center">server</td>
<td align="center">服务器名字</td>
</tr>
<tr>
<td align="center">WWW-Authenticate</td>
<td align="center">获取资源需要的验证信息</td>
</tr>
</tbody></table>
</li>
<li><p>实体首部</p>
<table>
<thead>
<tr>
<th align="center">实体字段</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">allow</td>
<td align="center">资源的正确请求方式</td>
</tr>
<tr>
<td align="center">content-encoding</td>
<td align="center">内容的编码格式</td>
</tr>
<tr>
<td align="center">content-language</td>
<td align="center">内容使用的语言</td>
</tr>
<tr>
<td align="center">content-length</td>
<td align="center">request body长度</td>
</tr>
<tr>
<td align="center">content-location</td>
<td align="center">返回数据的备用地址</td>
</tr>
<tr>
<td align="center">content-MD5</td>
<td align="center">base64加密格式的内容MD5检验值</td>
</tr>
<tr>
<td align="center">content-range</td>
<td align="center">内容的位置范围</td>
</tr>
<tr>
<td align="center">content-Type</td>
<td align="center">内容的媒体类型</td>
</tr>
<tr>
<td align="center">expires</td>
<td align="center">内容的过期时间</td>
</tr>
<tr>
<td align="center">last-modified</td>
<td align="center">内容的最后修改时间</td>
</tr>
</tbody></table>
</li>
</ol>
<h5 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h5><h6 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h6><ol>
<li>表示目前是协议的中间状态，还需要后续操作</li>
<li>101 Switching Protocols。在HTTP升级为WebSocket的时候，如果服务器同意变更，就会发送状态码 101。</li>
</ol>
<h6 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h6><ol>
<li>200 表示从客户端发送给服务器的请求被正常处理并返回</li>
<li>204 表示客户端发送给服务器的请求得到了成功处理，但在返回的响应报文中不含实体的主体部分（没有资源可以返回）</li>
<li>205 表示客户端发送给服务器的请求得到了成功处理，但在返回的响应报文中不含实体的主体部分（没有资源可以返回），与204不同的是要求请求方重置内容</li>
<li>206 表示客户端进行了范围请求，并且服务器成功执行了这部分的get请求，响应报文中包含由content-range指定范围的实体内容</li>
</ol>
<h6 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h6><ol>
<li>301 永久性重定向 表示请求的资源被分配了新的URL，之后使用更改的URL，响应的location首部中应该包含资源现在所处的URL。默认情况下，永久重定向是会被浏览器缓存的</li>
<li>302 临时性重定向 表示请求的资源被分配了新的URL，希望本次访问使用新的URL</li>
<li>303 表示请求的资源被分配了新的URL，应使用GET方法定向获取请求的资源，不允许客户端再重定向时改变请求的方法</li>
<li>304 表示客户端发送附带条件（是指采用GET方法的请求报文中包含if-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部）的请求时，服务器端允许访问资源，但是请求为满足条件的情况下返回改状态码；</li>
<li>307 与303有着相同的含义，307会遵照浏览器标准不会从POST变成GET；（不同浏览器可能会出现不同的情况）；</li>
<li>308 此状态码类似于301，但不允许从POST改为GET的请求方法</li>
</ol>
<h6 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h6><ol>
<li>400 表示请求报文中存在语法错误</li>
<li>401 未经许可，需要通过HTTP认证</li>
<li>403 服务器拒绝本次访问（访问权限出现问题）</li>
<li>404 表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原型时使用</li>
</ol>
<h6 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h6><ol>
<li>500 表示服务器在执行请求时发生错误，也有可能是web应用存在的bug或者某些临时的错误</li>
<li>503 表示服务器暂时处于超负载或正在进行停机维护，无法处理请求</li>
</ol>
<h5 id="HTTP优点"><a href="#HTTP优点" class="headerlink" title="HTTP优点"></a>HTTP优点</h5><ol>
<li>灵活可拓展</li>
<li>可靠传输</li>
<li>请求-应答</li>
<li>无状态。这里的状态指的是通信过程中的上下文信息，而每次HTTP请求都是独立、无关的，默认不需要保留状态信息。</li>
</ol>
<h5 id="HTTP缺点"><a href="#HTTP缺点" class="headerlink" title="HTTP缺点"></a>HTTP缺点</h5><ol>
<li>无状态。<ul>
<li>在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，这时无状态就是http的缺点</li>
<li>另外一些引用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，此时就是优点</li>
</ul>
</li>
<li>明文传输</li>
<li>队头阻塞问题</li>
</ol>
<h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><h5 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h5><p>https：是以安全为目的的HTTP通道，简单来说就是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。https的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。</p>
<h5 id="https的工作原理"><a href="#https的工作原理" class="headerlink" title="https的工作原理"></a>https的工作原理</h5><ol>
<li>客户使用https url访问服务器，则要求web服务器建立ssl链接</li>
<li>web 服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。 </li>
<li>客户端和 web 服务器端开始协商 SSL 链接的安全等级，也就是加密等级。 </li>
<li>客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。 </li>
<li>web 服务器通过自己的私钥解密出会话密钥。 web 服务器通过会话密钥加密与客户端之间的通信</li>
</ol>
<h5 id="https的优点"><a href="#https的优点" class="headerlink" title="https的优点"></a>https的优点</h5><ol>
<li>使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li>
<li>HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。 </li>
<li>HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻 击的成本。</li>
</ol>
<h5 id="https的缺点"><a href="#https的缺点" class="headerlink" title="https的缺点"></a>https的缺点</h5><ol>
<li>https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。 </li>
<li>https 缓存不如 http 高效，会增加数据开销。 </li>
<li>SSL 证书也需要钱，功能越强大的证书费用越高。 </li>
<li>SSL 证书需要绑定 IP，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗。</li>
</ol>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ol>
<li>http传输的数据都是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高</li>
<li>https协议需要ca证书，费用较高；http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议，使用不同的链接方式，端口也不同，一般而言，http协议的端口为80，https的端口为443</li>
<li>http的链接很简单，是无状态的；https协议是由ssl+http协议构成的可进行加密传输，身份认证的网络协议，比http协议更安全</li>
</ol>
<h3 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h3><ol>
<li>https还是通过HTTP来传递信息，但是信息通过TLS协议进行了加密</li>
<li>TLS协议位于传输层之上，应用层之下</li>
<li>在TLS中使用了两种加密技术，分别为：对称加密和非对称加密</li>
</ol>
<h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><ol>
<li>两边拥有相同的秘钥，两边都知道如何将密文加密解密</li>
<li>这种加密⽅式固然很好，但是问题就在于如何让双⽅知道秘钥。因为传输数据都是⾛的⽹<br>络，如果将秘钥通过⽹络的⽅式传递的话，⼀旦秘钥被截获就没有加密的意义的。</li>
</ol>
<h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h4><ol>
<li>有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须用私钥解密，私钥只有分发公钥的一方才知道</li>
<li>这种加密方式就可以完美解决对称加密存在的问题，假设现在两端需要使用对称加密，那么在此之前，可以先使用非对称加密交换秘钥</li>
</ol>
<h4 id="TLS握手过程"><a href="#TLS握手过程" class="headerlink" title="TLS握手过程"></a>TLS握手过程</h4><ol>
<li>客户端发送一个随机值以及需要的协议和加密方式</li>
<li>服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，并且发送自己的证书</li>
<li>客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书</li>
<li>服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成秘钥，接下来的通信就可以通过该秘钥来加密解密</li>
<li>通过上述步骤可知，在TLS握手阶段，两端使用非对称加密来通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/01/vue/vue%E5%8E%9F%E7%90%86/vue%E5%8E%9F%E7%90%86%E7%AF%87%E2%80%94%E2%80%94%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/01/vue/vue%E5%8E%9F%E7%90%86/vue%E5%8E%9F%E7%90%86%E7%AF%87%E2%80%94%E2%80%94%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">vue原理篇——双向绑定原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-01 23:27:00" itemprop="dateCreated datePublished" datetime="2022-03-01T23:27:00+08:00">2022-03-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-09 21:24:23" itemprop="dateModified" datetime="2022-05-09T21:24:23+08:00">2022-05-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><ol>
<li>vue采用的是数据劫持和发布订阅相结合的方式</li>
<li>数据劫持主要是通过object.defineProperty实现的</li>
</ol>
<h4 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h4><ol>
<li>object.defineProperty内部有get和set属性，当访问属性时，会自动调用get函数，设置属性时，会自动执行set函数</li>
<li>MVVM模式在于数据与视图保持同步，数据改变时自动更新视图，视图发生变化时更新数据</li>
<li>因此，需要做到数据改变时自动更新视图，则需要使用object.defineProperty，属性变化时，自动触发set去更新视图</li>
</ol>
<h4 id="observer-dep-watcher"><a href="#observer-dep-watcher" class="headerlink" title="observer-dep-watcher"></a>observer-dep-watcher</h4><ol>
<li>数据劫持是通过 Object.defineProperty 方法，需要一个监听器observer来监听属性的变化</li>
<li>属性发生变化时，需要一个watcher订阅者来更新视图</li>
<li>在通知watcher订阅者执行更新函数去取更新视图的过程中，可能会有多个订阅者，所以要创建一个容器Dep做统一的管理<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">observer</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!data || <span class="keyword">typeof</span> data !== <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(data).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">defineReactive</span>(data, key, data[key]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">data, key, value</span>) &#123;</span><br><span class="line">  <span class="comment">//递归调用，监听所有属性</span></span><br><span class="line">  <span class="title function_">observer</span>(value);</span><br><span class="line">  <span class="keyword">var</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>();</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, key, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">        <span class="comment">// 有新增属性时，在get中把属性添加到dep容器中</span></span><br><span class="line">        dep.<span class="title function_">addSub</span>(<span class="title class_">Dep</span>.<span class="property">target</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">newVal</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (value !== newVal) &#123;</span><br><span class="line">        value = newVal;</span><br><span class="line">        dep.<span class="title function_">notify</span>(); <span class="comment">//通知订阅器</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dep容器，用来存放watcher</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dep</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">subs</span> = [];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Dep</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">addSub</span> = <span class="keyword">function</span> (<span class="params">sub</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Dep</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">notify</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;属性变化通知 Watcher 执行更新视图函数&#x27;</span>);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">    sub.<span class="title function_">update</span>(); <span class="comment">// 执行更新函数</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="watcher"><a href="#watcher" class="headerlink" title="watcher"></a>watcher</h4><ol>
<li>watcher主要是接收属性变化的通知，然后执行更新函数去更新视图<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Watcher</span>(<span class="params">vm, prop, callback</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">vm</span> = vm;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">prop</span> = prop;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">callback</span> = callback;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">value</span> = <span class="variable language_">this</span>.<span class="title function_">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Watcher</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">update</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">$data</span>[<span class="variable language_">this</span>.<span class="property">prop</span>];</span><br><span class="line">    <span class="keyword">const</span> oldVal = <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line">    <span class="keyword">if</span> (value !== oldVal) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">callback</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="variable language_">this</span>; <span class="comment">//储存订阅器</span></span><br><span class="line">    <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">$data</span>[<span class="variable language_">this</span>.<span class="property">prop</span>]; <span class="comment">//因为属性被监听，这一步会执行监听器里的 get方法</span></span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="Compile解析器"><a href="#Compile解析器" class="headerlink" title="Compile解析器"></a>Compile解析器</h4><ol>
<li>compile的主要作用一个是用来解析指令初始化模板，一个是用来添加订阅者，绑定更新函数</li>
<li>然后对整个节点和指令进行处理编译，根据不同的节点去调用不同的渲染函数，绑定更新函数，编译完成之后，再把DOM片段添加到页面中</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B/" class="post-title-link" itemprop="url">线程和进程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-03-01 22:04:49 / Modified: 23:29:07" itemprop="dateCreated datePublished" datetime="2022-03-01T22:04:49+08:00">2022-03-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><ol>
<li>进程是系统进行资源分配和调度的基本单位,是操作系统结构的基础</li>
<li>进程是线程的容器</li>
<li>程序是指令、数据及其组织形式的描述，进程是程序的实体</li>
<li>线程 + 内存(逻辑内存。指的是内存的寻址空间) + 文件&#x2F;网络句柄</li>
<li>通过TCP&#x2F;IP的端口进行进程间的交互</li>
</ol>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ol>
<li>线程是操作系统能够进行运算调度的最小单位</li>
<li>一个进程可以并发多个线程，每个线程并行执行不同的任务</li>
<li>栈 + PC（程序计数器） + TLS（线程本地存储）</li>
<li>在共享的内存上，只要线程的指针指向同一个就可以看到各自的内存</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>进程要分配一大部分内存，二线程只需要分配一部分栈即可</li>
<li>一个程序至少有一个进程，一个进程至少有一个线程</li>
<li>进程是资源分配的最小单位，线程是程序执行的最小单位</li>
<li>一个线程可以创建和撤销另一个线程，同一个进程中的多个线程可以并发执行</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/18/JavaScript/js%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/18/JavaScript/js%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5/" class="post-title-link" itemprop="url">js单线程和异步</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-01-18 23:42:44" itemprop="dateCreated datePublished" datetime="2022-01-18T23:42:44+08:00">2022-01-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-03-01 23:29:30" itemprop="dateModified" datetime="2022-03-01T23:29:30+08:00">2022-03-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="js单线程和异步"><a href="#js单线程和异步" class="headerlink" title="js单线程和异步"></a>js单线程和异步</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>js是单线程语言，所以它本身不是异步的，但是 js的宿主环境（比如浏览器，Node）是多线程的，宿主环境通过某种方式（事件驱动）使得js具备了异步的属性</p>
<h4 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h4><ol>
<li>js是单线程语言，浏览器只分配给js一个主线程，用来执行任务函数，但一次只能执行一个任务，这些任务形成一个任务队列排队等候执行，但前端的某些任务是非常耗时的，比如网络请求、定时器和事件监听。</li>
<li>如果让他们和别的任务一样，排队等候执行的话，执行效率会非常低，甚至导致页面的假死</li>
<li>所以，浏览器为这些耗时任务开辟了另外的线程，主要包括http请求线程，浏览器定时触发器、浏览器事件触发线程，这些任务是异步的</li>
</ol>
<h4 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h4><ol>
<li>浏览器为网络请求这样的异步任务单独开了一个线程，这些异步任务完成后，通过回调函数通知主线程。</li>
<li>程序是事件驱动的，每个事件都会绑定相应的回调函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(time is out);</span><br><span class="line">&#125;，<span class="number">50</span>）;</span><br></pre></td></tr></table></figure></li>
<li>执行上面这段代码的时候，浏览器异步执行计时操作，当50ms到了后，会触发定时事件，这个时候，就会把回调函数放到任务队列里。整个程序就是通过这样的一个个事件驱动起来的。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/18/vue/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/18/vue/vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">vue响应式原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-18 22:42:27 / Modified: 22:55:33" itemprop="dateCreated datePublished" datetime="2022-01-18T22:42:27+08:00">2022-01-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/vue/" itemprop="url" rel="index"><span itemprop="name">vue</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h3><h4 id="手写实现"><a href="#手写实现" class="headerlink" title="手写实现"></a>手写实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Dep</span> = &#123;</span><br><span class="line">    <span class="attr">clientList</span>: &#123;&#125;, <span class="comment">// 容器</span></span><br><span class="line">    <span class="comment">// 添加订阅</span></span><br><span class="line">    <span class="attr">listen</span>: <span class="keyword">function</span> (<span class="params">key, fn</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="variable language_">this</span>.<span class="property">clientList</span>[key]) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">clientList</span>[key] = []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">clientList</span>[key].<span class="title function_">push</span>(fn)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布</span></span><br><span class="line">    <span class="attr">trigger</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> key = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">        <span class="keyword">let</span> fns = <span class="variable language_">this</span>.<span class="property">clientList</span>[key]</span><br><span class="line">        <span class="keyword">if</span>(!fns || fns.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>,fn;fn = fns[i++];) &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dataHi = <span class="keyword">function</span> (<span class="params">&#123;data, tag, datakey, selector&#125;</span>) &#123; </span><br><span class="line">    <span class="keyword">let</span> value = <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    el = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(selector)</span><br><span class="line">    <span class="keyword">debugger</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, datakey, &#123;</span><br><span class="line">        <span class="comment">// 取值</span></span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">              value = val</span><br><span class="line">            <span class="comment">//   发布</span></span><br><span class="line">            <span class="title class_">Dep</span>.<span class="title function_">trigger</span>(tag, val)</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 订阅</span></span><br><span class="line">    <span class="title class_">Dep</span>.<span class="title function_">listen</span>(tag, <span class="keyword">function</span> (<span class="params">text</span>) &#123;</span><br><span class="line">        el.<span class="property">innerHtml</span> = text</span><br><span class="line">      &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">        订阅视图-<span class="number">1</span>： &lt;span <span class="keyword">class</span>=<span class="string">&quot;box-1&quot;</span>&gt;&lt;/span&gt;</span><br><span class="line">        订阅视图-<span class="number">2</span>： &lt;span <span class="keyword">class</span>=<span class="string">&quot;box-2&quot;</span>&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./响应式原理.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">        <span class="title function_">dataHi</span>(&#123;</span><br><span class="line">            <span class="attr">data</span>: obj,</span><br><span class="line">            <span class="attr">tag</span>: <span class="string">&#x27;view-1&#x27;</span>,</span><br><span class="line">            <span class="attr">datakey</span>: <span class="string">&#x27;one&#x27;</span>,</span><br><span class="line">            <span class="attr">selector</span>: <span class="string">&#x27;.box-1&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="title function_">dataHi</span>(&#123;</span><br><span class="line">            <span class="attr">data</span>: obj,</span><br><span class="line">            <span class="attr">tag</span>: <span class="string">&#x27;view-2&#x27;</span>,</span><br><span class="line">            <span class="attr">datakey</span>: <span class="string">&#x27;two&#x27;</span>,</span><br><span class="line">            <span class="attr">selector</span>: <span class="string">&#x27;.box-2&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 1. 初始化赋值</span></span><br><span class="line">        obj.<span class="property">one</span> = <span class="string">&#x27;这是视图一&#x27;</span></span><br><span class="line">        obj.<span class="property">two</span> = <span class="string">&#x27;这是视图二&#x27;</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br><span class="line">        <span class="comment">// 2. 劫持数组，更新者负责重新渲染N次</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">109</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">39</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
